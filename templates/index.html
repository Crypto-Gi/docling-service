<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Docling Markdown Converter</title>
    <link rel="stylesheet" href="/static/styles.css" />
  </head>
  <body>
    <main class="container">
      <h1>Docling Markdown Converter</h1>
      <p>
        Upload a document (PDF, Word, Excel, PowerPoint) or provide a public URL and Docling will convert it to
        Markdown. GPU acceleration is used automatically when available.
      </p>

      <div id="cloud-storage-status" class="cloud-status" hidden>
        <p>
          <strong>Cloud Storage:</strong> 
          <span id="cloud-provider"></span>
          <span id="cloud-badge" class="badge"></span>
        </p>
      </div>

      <section class="panel">
        <form id="upload-form">
          <label class="field">
            <span>Upload Document</span>
            <input type="file" name="file" id="file" accept="application/pdf,.pdf,.docx,.xlsx,.pptx,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.openxmlformats-officedocument.presentationml.presentation" />
          </label>
          <p><strong>Limit:</strong> Files larger than {{ max_upload_mb }}&nbsp;MB cannot be uploaded.</p>
          <div class="divider">or</div>
          <label class="field">
            <span>Remote file URL</span>
            <input type="url" name="source_url" id="source_url" placeholder="https://example.com/document.pdf" />
          </label>
          
          <details class="advanced-options">
            <summary>Advanced Options</summary>
            <label class="field">
              <span>Webhook Callback URL (optional)</span>
              <input type="url" name="callback_url" id="callback_url" placeholder="https://your-server.com/webhook" />
              <small>Receive a POST notification when conversion completes or fails</small>
            </label>
          </details>
          
          <button type="submit" class="primary">Convert</button>
        </form>

        <div id="status" class="status" hidden>
          <p><strong>Status:</strong> <span id="status-text">pending</span></p>
          <div id="progress" class="progress" hidden>
            <span id="progress-text">Processing‚Ä¶</span>
          </div>
          <p id="detail" hidden><strong>Detail:</strong> <span id="detail-text"></span></p>
          <p id="pages-info" hidden><strong>Pages:</strong> <span id="pages-text"></span></p>
          <div id="download" class="download" hidden>
            <a id="download-link" href="#" target="_blank" download>
              <span aria-hidden="true">‚¨áÔ∏è</span>
              <span id="download-label">Download Markdown</span>
            </a>
          </div>
        </div>
      </section>
    </main>

    <!-- Upload Progress Overlay - Compact Bottom Right -->
    <div id="upload-overlay" class="upload-overlay" hidden>
      <div class="upload-card">
        <div class="upload-header">
          <div class="upload-icon-small">üìÑ</div>
          <div class="upload-title-section">
            <h4 id="upload-title">Processing Document</h4>
            <p id="upload-message" class="upload-subtitle">Preparing upload...</p>
          </div>
        </div>
        
        <div class="upload-progress-bar-slim">
          <div id="upload-progress-fill" class="upload-progress-fill"></div>
        </div>
        
        <div id="upload-stages" class="upload-stages-compact">
          <div class="stage-compact" id="stage-upload">
            <span class="stage-dot">‚óè</span>
            <span class="stage-label">Upload</span>
          </div>
          <div class="stage-compact" id="stage-processing">
            <span class="stage-dot">‚óè</span>
            <span class="stage-label">Process</span>
          </div>
          <div class="stage-compact" id="stage-images">
            <span class="stage-dot">‚óè</span>
            <span class="stage-label">Images</span>
          </div>
          <div class="stage-compact" id="stage-cloud">
            <span class="stage-dot">‚óè</span>
            <span class="stage-label">Cloud</span>
          </div>
          <div class="stage-compact" id="stage-complete">
            <span class="stage-dot">‚óè</span>
            <span class="stage-label">Done</span>
          </div>
        </div>
      </div>
    </div>

    <script>
      const form = document.getElementById("upload-form");
      const statusBox = document.getElementById("status");
      const statusText = document.getElementById("status-text");
      const detailBox = document.getElementById("detail");
      const detailText = document.getElementById("detail-text");
      const downloadBox = document.getElementById("download");
      const downloadLink = document.getElementById("download-link");
      const downloadLabel = document.getElementById("download-label");
      const progressBox = document.getElementById("progress");
      const progressText = document.getElementById("progress-text");

      let pollTimer = null;
      let pollStart = null;

      // Upload overlay elements
      const uploadOverlay = document.getElementById("upload-overlay");
      const uploadTitle = document.getElementById("upload-title");
      const uploadMessage = document.getElementById("upload-message");
      const uploadProgressFill = document.getElementById("upload-progress-fill");
      
      // Stage elements
      const stages = {
        upload: document.getElementById("stage-upload"),
        processing: document.getElementById("stage-processing"),
        images: document.getElementById("stage-images"),
        cloud: document.getElementById("stage-cloud"),
        complete: document.getElementById("stage-complete")
      };

      // Upload overlay functions
      function showUploadOverlay() {
        uploadOverlay.hidden = false;
        updateUploadProgress(0, "Preparing upload...");
      }

      function hideUploadOverlay() {
        uploadOverlay.hidden = true;
        resetStages();
      }

      function updateUploadProgress(percent, message) {
        uploadProgressFill.style.width = `${percent}%`;
        uploadMessage.textContent = message;
      }

      function updateStage(stageName, status) {
        const stage = stages[stageName];
        if (!stage) return;
        
        if (status === 'active') {
          stage.classList.add('active');
          stage.classList.remove('complete');
        } else if (status === 'complete') {
          stage.classList.remove('active');
          stage.classList.add('complete');
        } else {
          stage.classList.remove('active', 'complete');
        }
      }

      function resetStages() {
        Object.keys(stages).forEach(key => updateStage(key, 'pending'));
      }

      // Fetch and display cloud storage status
      async function loadCloudStorageStatus() {
        try {
          const response = await fetch('/api/cloud-storage/status');
          if (response.ok) {
            const status = await response.json();
            if (status.enabled && status.backend_ready) {
              const statusBox = document.getElementById('cloud-storage-status');
              const providerSpan = document.getElementById('cloud-provider');
              const badgeSpan = document.getElementById('cloud-badge');
              
              providerSpan.textContent = `${status.provider} (${status.upload_mode})`;
              badgeSpan.textContent = '‚úì Active';
              badgeSpan.className = 'badge badge-success';
              statusBox.hidden = false;
            }
          }
        } catch (error) {
          console.log('Cloud storage status unavailable:', error);
        }
      }

      // Load cloud storage status on page load
      loadCloudStorageStatus();

      async function pollStatus(taskId) {
        try {
          const response = await fetch(`/api/status/${taskId}`);
          if (!response.ok) {
            throw new Error("Failed to poll status");
          }
          const payload = await response.json();
          statusText.textContent = payload.status;
          
          // Update overlay based on status
          if (payload.status === "processing") {
            progressBox.hidden = false;
            
            // Use real progress data from API if available
            let progressInfo = "Processing‚Ä¶";
            if (payload.progress) {
              const pages = payload.progress.total_pages || '?';
              const elapsed = payload.progress.elapsed_seconds 
                ? Math.round(payload.progress.elapsed_seconds) 
                : 0;
              progressInfo = `Processing ${pages} pages‚Ä¶ (${elapsed}s elapsed)`;
              
              // Show pages info
              const pagesInfoBox = document.getElementById('pages-info');
              const pagesText = document.getElementById('pages-text');
              pagesText.textContent = `${pages} pages`;
              pagesInfoBox.hidden = false;
            } else {
              const elapsedSeconds = pollStart
                ? Math.floor((Date.now() - pollStart) / 1000)
                : 0;
              progressInfo = elapsedSeconds
                ? `Processing‚Ä¶ (${elapsedSeconds}s elapsed)`
                : "Processing‚Ä¶";
            }
            progressText.textContent = progressInfo;
            
            // Calculate elapsed for stage simulation
            const elapsedForStages = payload.progress 
              ? Math.round(payload.progress.elapsed_seconds || 0)
              : (pollStart ? Math.floor((Date.now() - pollStart) / 1000) : 0);
            
            // Update overlay stages
            updateStage('upload', 'complete');
            updateStage('processing', 'active');
            updateUploadProgress(40, progressInfo);
            
            // Simulate stages based on elapsed time
            if (elapsedForStages > 2) {
              updateStage('processing', 'complete');
              updateStage('images', 'active');
              updateUploadProgress(60, "Extracting images...");
            }
            if (elapsedForStages > 4) {
              updateStage('images', 'complete');
              updateStage('cloud', 'active');
              updateUploadProgress(80, "Uploading to cloud storage...");
            }
            if (elapsedForStages > 6) {
              updateStage('cloud', 'complete');
              updateStage('complete', 'active');
              updateUploadProgress(90, "Generating markdown...");
            }
          } else if (payload.status === "pending") {
            progressBox.hidden = false;
            progressText.textContent = "Queued";
            updateStage('upload', 'active');
            updateUploadProgress(20, "Queued for processing...");
          } else {
            progressBox.hidden = true;
          }
          
          if (payload.detail) {
            detailText.textContent = payload.detail;
            detailBox.hidden = false;
          } else {
            detailBox.hidden = true;
          }
          
          if (payload.download_url && payload.status === "completed") {
            // Complete all stages
            updateStage('complete', 'complete');
            updateUploadProgress(100, "‚úÖ Conversion complete!");
            
            setTimeout(() => {
              hideUploadOverlay();
              downloadLink.href = payload.download_url;
              downloadLabel.textContent = payload.output_filename || payload.source_name || "Download Markdown";
              downloadBox.hidden = false;
            }, 1500);
            
            clearInterval(pollTimer);
            pollStart = null;
          } else if (payload.status === "failed") {
            updateUploadProgress(100, "‚ùå Conversion failed");
            setTimeout(() => hideUploadOverlay(), 2000);
            clearInterval(pollTimer);
            pollStart = null;
          }
        } catch (error) {
          detailText.textContent = error.message;
          detailBox.hidden = false;
          updateUploadProgress(100, "‚ùå Error occurred");
          setTimeout(() => hideUploadOverlay(), 2000);
          clearInterval(pollTimer);
          pollStart = null;
        }
      }

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        detailBox.hidden = true;
        downloadBox.hidden = true;
        progressBox.hidden = false;
        progressText.textContent = "Queued";

        // Show upload overlay
        showUploadOverlay();
        updateStage('upload', 'active');
        updateUploadProgress(10, "Uploading document...");

        const formData = new FormData(form);
        const response = await fetch("/api/convert", {
          method: "POST",
          body: formData,
        });

        if (!response.ok) {
          const error = await response.json();
          detailText.textContent = error.detail || "Conversion failed";
          detailBox.hidden = false;
          statusText.textContent = "failed";
          statusBox.hidden = false;
          updateUploadProgress(100, "‚ùå Upload failed");
          setTimeout(() => hideUploadOverlay(), 2000);
          return;
        }

        const payload = await response.json();
        statusText.textContent = "pending";
        statusBox.hidden = false;
        pollStart = Date.now();

        // Update overlay after successful upload
        updateStage('upload', 'complete');
        updateUploadProgress(20, "Upload complete, processing...");

        if (pollTimer) {
          clearInterval(pollTimer);
        }
        pollTimer = setInterval(() => pollStatus(payload.task_id), 3000);
        pollStatus(payload.task_id);
      });
    </script>
  </body>
</html>
